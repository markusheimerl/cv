\documentclass[9pt,a4paper]{extarticle}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[margin=0.6in]{geometry}
\usepackage{multicol}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{array}
\usepackage{tabularx}
\usepackage{booktabs}

% Compact spacing
\setlength{\parindent}{0pt}
\setlength{\parskip}{2pt}
\setlist{nosep,leftmargin=12pt}

% Colors
\definecolor{sectioncolor}{RGB}{0,51,102}
\definecolor{subsectioncolor}{RGB}{0,76,153}

% Section formatting
\titleformat{\section}{\color{sectioncolor}\large\bfseries}{\thesection}{0.5em}{}
\titleformat{\subsection}{\color{subsectioncolor}\normalsize\bfseries}{\thesubsection}{0.5em}{}
\titlespacing*{\section}{0pt}{6pt}{3pt}
\titlespacing*{\subsection}{0pt}{4pt}{2pt}

% Header
\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{\textbf{Betriebssysteme Cheat Sheet - Kurs 01670 FernUni Hagen}}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% Fix for better table formatting
\renewcommand{\arraystretch}{1.1}

\begin{document}

\begin{center}
{\huge\textbf{Betriebssysteme - Das ultimative Cheat Sheet}}\\
\vspace{2mm}
{\large Basierend auf Kurs 01670 - FernUniversität in Hagen}
\end{center}

\vspace{3mm}
\hrule
\vspace{3mm}

\begin{multicols*}{2}
\small

\section{KE 1: Einführung \& Grundlagen}

\subsection{Was ist ein Betriebssystem (BS)?}
\textbf{Definition:} Menge von Programmen, die es ermöglichen, den Rechner zu betreiben und Anwendungsprogramme auf ihm auszuführen.

\textbf{Zwei Hauptsichten:}
\begin{itemize}
\item \textbf{Abstrakte/Virtuelle Maschine:} Verbirgt Hardware-Komplexität, bietet einfache Schnittstelle (API)
\item \textbf{Ressourcen-Manager:} Verwaltet \& verteilt Ressourcen (CPU, Speicher, Geräte) fair und effizient
\end{itemize}

\subsection{Aufgaben eines Betriebssystems}
\textbf{Klassische Aufgaben:}
\begin{itemize}
\item \textbf{Gerätesteuerung:} Verbergen der Hardware-Besonderheiten, Anbieten von Diensten
\item \textbf{Schutz:} Speicherschutz, Zugriffschutz zwischen Benutzern
\item \textbf{Fehlerbehandlung:} Division durch 0, illegale Adressen, Hardware-Defekte
\item \textbf{Mehrprogrammbetrieb:} Parallele Ausführung mehrerer Programme
\item \textbf{Prozess-Synchronisation/-Kommunikation:} Nachrichtenaustausch, Synchronisation
\item \textbf{Ressourcenverwaltung:} CPU, E/A-Geräte, Hauptspeicher, Kommunikationsverbindungen
\item \textbf{Kommandosprache:} Textuelle/grafische Schnittstelle zum System
\item \textbf{Administration:} Datensicherung, Systemkonfiguration, Leistungsüberwachung
\end{itemize}

\subsection{Systemarchitektur \& Ebenenmodell}
\textbf{Ebenenmodell (von unten nach oben):}
\begin{enumerate}
\item \textbf{Digitale Logikebene:} Gatter, Boole'sche Funktionen
\item \textbf{Mikroprogramm-Ebene:} Mikrobefehle, Mikroprogramme
\item \textbf{Konventionelle Maschinenebene:} Maschinenbefehle des Prozessors
\item \textbf{Betriebssystem-Ebene:} Systemaufrufe erweitern Maschinenebene
\item \textbf{Assembler-Sprachen:} Lesbare Namen für Maschinenbefehle
\item \textbf{Höhere Programmiersprachen:} Hardware-unabhängig
\end{enumerate}

\textbf{Betriebssystem-Komponenten:}
\begin{itemize}
\item \textbf{Kern (Kernel):} Programme, die immer im Hauptspeicher sind
\item \textbf{Standard-Bibliotheken:} Häufig benötigte Funktionen
\item \textbf{Dienstprogramme (Utilities):} Administration, Textverarbeitung
\end{itemize}

\subsection{Hardware-Grundlagen}
\textbf{Unterbrechungen (Interrupts):}
\begin{itemize}
\item \textbf{Hardware-Interrupts:} Asynchrone Signale von Geräten (E/A-Abschluss)
\item \textbf{Software-Interrupts (Traps):} Synchron durch Programmfehler oder Systemaufrufe
\item \textbf{Ablauf:} Signal → CPU unterbricht Programm → Unterbrechungsroutine → Programmfortsetzung
\item \textbf{Unterbrechungsvektor:} Tabelle mit Adressen der Unterbrechungsroutinen
\end{itemize}

\textbf{Speicherschutz:}
\begin{itemize}
\item \textbf{Grenzregister:} Trennt Benutzer- und Betriebssystem-Bereich
\item \textbf{Zweck:} Schutz des BS vor fehlerhaften/bösartigen Programmen
\end{itemize}

\textbf{System- und Benutzermodus:}
\begin{itemize}
\item \textbf{Benutzermodus (User Mode):} Eingeschränkte Befehle, Speicherschutz aktiv
\item \textbf{Systemmodus (Kernel Mode):} Alle Befehle erlaubt, Speicherschutz deaktiviert
\item \textbf{Supervisor Call (SVC):} Kontrollierter Übergang User→Kernel für Systemaufrufe
\end{itemize}

\subsection{Mehrprogrammbetrieb}
\textbf{Motivation:}
\begin{itemize}
\item \textbf{Auslastungsverbesserung:} CPU arbeitet während E/A-Wartezeiten anderer Prozesse
\item \textbf{Parallelität:} Mehrere Benutzer/Programme gleichzeitig
\item \textbf{Virtueller Prozessor:} Jeder Prozess hat Eindruck einer eigenen CPU
\end{itemize}

\textbf{Zeitscheiben:}
\begin{itemize}
\item \textbf{Zeitgeber (Timer):} Hardware-Komponente für regelmäßige Unterbrechungen
\item \textbf{Zeitscheibenablauf:} Unterbrechung nach Ablauf der zugeteilten Zeit
\item \textbf{Prozesswechsel:} Umschaltung zwischen Prozessen
\end{itemize}

\subsection{Betriebsarten}
\textbf{Interaktiver Betrieb (Dialog):}
\begin{itemize}
\item Sofortige Programmausführung, direkte Benutzer-Programm-Kommunikation
\item Time-Sharing: Mehrbenutzer-Dialogsysteme
\item Optimierungsziel: Kurze Antwortzeiten
\end{itemize}

\textbf{Stapelbetrieb (Batch):}
\begin{itemize}
\item Jobs werden in Warteschlange eingereiht, keine direkte Kommunikation
\item Optimierungsziel: Maximale Ressourcenauslastung
\item Höhere Durchsatzraten, längere Wartezeiten akzeptabel
\end{itemize}

\textbf{Hintergrundausführung:}
\begin{itemize}
\item Programme laufen parallel zu interaktiven Prozessen
\item Keine direkte Benutzerinteraktion während der Ausführung
\end{itemize}

\textbf{Realzeitbetrieb:}
\begin{itemize}
\item Harte Zeitgrenzen müssen eingehalten werden
\item Zeitkritische Prozesse haben höchste Priorität
\item Erfordert speziell konstruierten Betriebssystemkern
\end{itemize}

\subsection{Systemstart (Bootstrap)}
\textbf{Ladevorgang:}
\begin{itemize}
\item \textbf{Firmware/BIOS:} In ROM/EPROM gespeichert
\item \textbf{Urlader (Bootstrap Loader):} Lädt Betriebssystem von Festplatte
\item \textbf{Master Boot Record (MBR):} Enthält Startinformationen
\item \textbf{Boot Manager:} Auswahl zwischen mehreren Betriebssystemen
\end{itemize}

\subsection{Historisches Beispiel: CP/M}
\textbf{Komponenten:}
\begin{itemize}
\item \textbf{BIOS:} Hardware-abhängige Gerätetreiber
\item \textbf{BDOS:} Hardware-unabhängige Dateiverwaltung
\item \textbf{CCP:} Kommandointerpreter (Shell)
\item \textbf{TPA:} Transient Program Area (Benutzerbereich)
\end{itemize}

\section{KE 2: Prozesse \& Scheduling}

\subsection{Programm vs. Prozess}
\begin{itemize}
\item \textbf{Programm:} Statische Formulierung eines Algorithmus (Programmtext)
\item \textbf{Prozess:} Ablaufendes Programm inklusive aktueller Stand des Befehlszählers, Registerinhalte und Hauptspeicherbereich mit Variablenbelegungen
\end{itemize}

\subsection{Prozessmerkmale}
\textbf{Prozesszustände:}
\begin{itemize}
\item \textbf{erzeugt:} Datenstrukturen werden erstellt, Adressraum zugewiesen
\item \textbf{bereit:} Rechenbereit, wartet auf Prozessorzuteilung
\item \textbf{rechnend:} Prozessor ist zugeteilt, führt Anweisungen aus
\item \textbf{blockiert:} Wartet auf Ereignis (z.B. E/A)
\item \textbf{beendet:} Programmausführung ist beendet
\end{itemize}

\textbf{Speicherbereich eines Prozesses:}
\begin{itemize}
\item \textbf{Programmsegment:} Ausführbarer Code (ändert sich nicht)
\item \textbf{Stacksegment:} Programmstack mit Aktivierungsblöcken
\item \textbf{Datensegment:} Daten des Programms
\end{itemize}

\textbf{Prozesskontrollblock (PCB):}
\begin{itemize}
\item \textbf{Prozessidentifikation:} Eindeutige Prozess-ID
\item \textbf{Prozessorstatus:} Programmzähler, alle Register
\item \textbf{Prozesskontrollinformationen:} Zustand, Priorität, Speicherbereich, geöffnete Dateien, Buchhaltung, Besitzer
\end{itemize}

\subsection{Zustandsübergänge \& Prozesswechsel}
\textbf{Wichtige Übergänge:}
\begin{itemize}
\item erzeugt → bereit (2): Ressourcen zugeteilt
\item bereit → rechnend (3): Prozessor zugeteilt
\item rechnend → blockiert (5): Warten auf Ereignis
\item blockiert → bereit (6): Ereignis eingetreten
\item rechnend → bereit (4): Zeitscheibe abgelaufen oder freiwillige Abgabe
\item rechnend → beendet (7): Prozess terminiert
\end{itemize}

\textbf{Dispatcher:} Führt Prozesswechsel durch
\begin{itemize}
\item Sichert Prozessorzustand (Register, Programmzähler)
\item Übergibt PCB an Scheduler
\item Stellt Zustand des neuen Prozesses wieder her
\end{itemize}

\textbf{Präemptiv vs. Nicht-präemptiv:}
\begin{itemize}
\item \textbf{Nicht-präemptiv:} Nur Prozess selbst gibt Prozessor ab
\item \textbf{Präemptiv:} Betriebssystem kann Prozessor entziehen (Timer-Interrupt)
\end{itemize}

\subsection{Scheduling-Strategien}
\textbf{Qualitätsmaßstäbe:}
\begin{itemize}
\item Prozessorauslastung, Durchlaufzeit, Durchsatz, Antwortzeit, Fairness
\item CPU burst: Zeit, die Prozess den Prozessor am Stück behalten will
\end{itemize}

\textbf{Nicht-präemptive Verfahren:}

\begin{center}
\begin{tabular}{|p{2.2cm}|p{2.8cm}|p{2.8cm}|}
\hline
\textbf{Verfahren} & \textbf{Vorteile} & \textbf{Nachteile} \\
\hline
\textbf{FCFS} & Einfach, fair, geringer Verwaltungsaufwand & Kurze Prozesse warten lange (Convoy-Effekt) \\
\hline
\textbf{SJF} & Minimale mittlere Wartezeit & Verhungern langer Prozesse, Bedienzeit unbekannt \\
\hline
\textbf{Priority} & Wichtige Aufgaben schnell & Verhungern bei statischen Prioritäten \\
\hline
\end{tabular}
\end{center}

\textbf{Präemptive Verfahren:}

\begin{center}
\begin{tabular}{|p{2.2cm}|p{2.8cm}|p{2.8cm}|}
\hline
\textbf{Verfahren} & \textbf{Vorteile} & \textbf{Nachteile} \\
\hline
\textbf{Round Robin} & Sehr fair, gut für interaktive Systeme & Overhead durch Kontextwechsel \\
\hline
\textbf{SRTF} & Optimal für bekannte Zeiten & Verhungern, viele Unterbrechungen \\
\hline
\textbf{Priority (präemptiv)} & Flexible Prioritäten & Komplexer \\
\hline
\end{tabular}
\end{center}

\textbf{Quantum-Wahl bei Round Robin:}
\begin{itemize}
\item Zu klein: Hoher Verwaltungsaufwand
\item Zu groß: Schlechte Antwortzeiten
\item Optimal: Etwas größer als typische Interaktionszeit
\end{itemize}

\subsection{Kombinierte Strategien}
\textbf{Feedback Scheduling:}
\begin{itemize}
\item Berücksichtigt Vergangenheit des Prozesses
\item Aging: Priorität steigt mit Wartezeit → verhindert Verhungern
\item Rechenzeitabhängig: Neue Prozesse hohe Priorität + kleine Zeitscheibe
\item Bei Quantumverbrauch: Niedrigere Priorität + größere Zeitscheibe
\end{itemize}

\textbf{Multiple Queues:}
\begin{itemize}
\item Verschiedene Klassen (System-, Dialog-, Hintergrundprozesse)
\item Jede Klasse eigene Warteschlange + Scheduler
\item Prozessorzeit-Verteilung zwischen Klassen (z.B. 60\%/30\%/10\%)
\end{itemize}

\textbf{Linux-Scheduler:}
\begin{itemize}
\item \textbf{O(1)-Scheduler:} Konstante Laufzeit, Prioritäten 0-139, aktive/abgelaufene Gruppen
\item \textbf{CFS (Completely Fair):} Virtuelle Zeit pro Prozess, perfekte Fairness angestrebt
\end{itemize}

\subsection{Threads (Leichtgewichtige Prozesse)}
\textbf{Konzept:}
\begin{itemize}
\item Mehrere Ausführungspfade pro Prozess
\item \textbf{Gemeinsam:} Code, Daten, geöffnete Dateien
\item \textbf{Separat:} Programmzähler, Register, Stack
\end{itemize}

\textbf{Realisierungen:}
\begin{center}
\begin{tabular}{|p{3.5cm}|p{4.3cm}|}
\hline
\textbf{Benutzer-Threads} & \textbf{Kernel-Threads} \\
\hline
+ Einfache Realisierung & + Echte Parallelität auf Multiprozessoren \\
+ Schnelles Umschalten & + Ein blockierender Thread stoppt nicht alle \\
- Blockierung stoppt alle & - Aufwändige Realisierung \\
- Keine echte Parallelität & - Langsameres Umschalten \\
\hline
\end{tabular}
\end{center}

\textbf{Anwendungsgebiete:}
\begin{itemize}
\item Mehrprozessor-Maschinen (Parallelisierung)
\item Gerätetreiber (parallele Anfragen-Bearbeitung)
\item Verteilte Systeme (Server mit mehreren Clients)
\end{itemize}

\section{KE 3: Hauptspeicherverwaltung}

\subsection{Grundlagen}
\textbf{Logische vs. Physische Adressen:}
\begin{itemize}
\item \textbf{Physische Adresse:} Reale Adresse einer Speicherzelle im RAM
\item \textbf{Logische/Virtuelle Adresse:} Vom Programm erzeugte Adresse, hardware-unabhängig
\item \textbf{MMU (Memory Management Unit):} Hardware zwischen CPU und Hauptspeicher für Adressumsetzung
\end{itemize}

\textbf{Übersetzer, Binder und Lader:}
\begin{itemize}
\item \textbf{Quellprogramm-Modul} → \textbf{Compiler} → \textbf{Bindemodul} → \textbf{Binder} → \textbf{Lademodul} → \textbf{Lader} → \textbf{Geladenes Programm}
\item \textbf{Absolute Adressen:} Binder kennt logischen Adressraum bereits
\item \textbf{Relative Adressen:} Lader addiert Startadresse zu relativen Adressen
\item \textbf{Basisregister-Adressierung:} (Registernummer, Offset) für verschiebbare Programme
\item \textbf{Dynamisches Binden:} Bindung zur Laufzeit, Module werden bei Bedarf nachgeladen
\end{itemize}

\subsection{Einfache zusammenhängende Speicherzuweisung}
\textbf{Konzept:} Ein Prozess = ein zusammenhängender Speicherbereich
\begin{itemize}
\item Betriebssystemkern ab Adresse 0
\item Anwenderprogramm ab Adresse a
\item \textbf{Speicherschutz:} Grenzregister verhindert Zugriff auf Adressen $<$ a
\item \textbf{Swapping:} Kompletter Prozess wird auf Sekundärspeicher aus-/eingelagert
\end{itemize}

\subsection{Mehrfache zusammenhängende Speicherzuweisung}
\textbf{MFT (Multiprogramming with Fixed Tasks):}
\begin{itemize}
\item Feste Segmentgrößen beim Systemstart
\item \textbf{Interne Fragmentierung:} Zugewiesener Speicher $>$ Bedarf
\item \textbf{Best-available-fit:} Kleinstes ausreichendes Segment wählen
\item \textbf{Best-fit-only:} Nur Segmente verwenden, die nicht wesentlich größer sind
\end{itemize}

\textbf{MVT (Multiprogramming with Variable Tasks):}
\begin{itemize}
\item Variable Segmentgrößen je nach Bedarf
\item \textbf{Externe Fragmentierung:} Viele kleine, nicht nutzbare Lücken
\item \textbf{Lückenmanagement} erforderlich
\end{itemize}

\textbf{Speicherplatzvergabestrategien:}
\begin{itemize}
\item \textbf{First Fit:} Erste ausreichend große Lücke
\item \textbf{Next Fit:} Wie First Fit, aber ab letzter Zuteilung suchen
\item \textbf{Best Fit:} Kleinste ausreichend große Lücke (erzeugt kleine Restlücken)
\item \textbf{Worst Fit:} Größte Lücke wählen (große Restlücke bleibt nutzbar)
\item \textbf{Buddy-Verfahren:} Nur 2er-Potenzen, interne Fragmentierung, aber effiziente Verwaltung
\end{itemize}

\textbf{Kompaktifizierung (Garbage Collection):}
\begin{itemize}
\item Verschieben belegter Bereiche zur Zusammenlegung freier Bereiche
\item Hoher Aufwand, daher selten verwendet
\end{itemize}

\subsection{Nichtzusammenhängende Speicherzuweisung}
\textbf{Segmentierung:}
\begin{itemize}
\item \textbf{Trennung von Programm und Daten} in separate Segmente
\item Logische Adresse = (Segmentnummer, Relativadresse)
\item \textbf{Basisregister pro Segment} für Adressumsetzung
\item \textbf{Wiedereintrittsfähige Programme (Reentrant Code):} Ein Programmsegment für mehrere Prozesse
\item \textbf{Shared Libraries:} Gemeinsam benutzte Bindemodule
\end{itemize}

\subsection{Paging (Seitenorientierte Speicherverwaltung)}
\textbf{Grundkonzept:}
\begin{itemize}
\item \textbf{Seiten (Pages):} Logischer Adressraum in gleichgroße Blöcke (typisch 4 KB)
\item \textbf{Seitenrahmen (Page Frames):} Physischer Speicher in gleichgroße Blöcke
\item \textbf{Seitentabelle:} Bildet Seiten auf Seitenrahmen ab
\item Logische Adresse = (Seitennummer s, Offset d) mit s = v div p, d = v mod p
\end{itemize}

\textbf{Adressumsetzung:}
\begin{itemize}
\item Physische Adresse r = ST[s] × p + d
\item \textbf{TLB (Translation Lookaside Buffer):} Schneller Assoziativspeicher für häufig benutzte Seitentabellen-Einträge
\item \textbf{TLB Hit:} Eintrag im TLB gefunden (schnell)
\item \textbf{TLB Miss:} Zugriff auf Seitentabelle im Hauptspeicher (langsam)
\end{itemize}

\textbf{Zusätzliche Funktionen:}
\begin{itemize}
\item \textbf{Individueller Speicherschutz:} Protection-Bits pro Seite (read/write/execute)
\item \textbf{Shared Memory:} Seiten in mehreren Adressräumen einblenden
\item \textbf{Memory-Mapped Files:} Dateiseiten in virtuellen Speicher einblenden
\end{itemize}

\textbf{Implementierung:}
\begin{itemize}
\item \textbf{Mehrstufige Seitentabellen:} Bei großen Adressräumen (z.B. 32 Bit)
\item \textbf{Seitenrahmentabelle:} Globale Tabelle über Zustand aller Frames
\end{itemize}

\subsection{Virtueller Hauptspeicher}
\textbf{Demand Paging:}
\begin{itemize}
\item \textbf{Konzept:} Seiten werden erst bei Bedarf geladen, nicht alle Seiten eines Prozesses sind im RAM
\item \textbf{Seitenfehler (Page Fault):} Zugriff auf nicht geladene Seite → Trap → Einlagerung
\item \textbf{Present-Bit:} Zeigt an, ob Seite im Hauptspeicher liegt
\item \textbf{Dirty Bit:} Zeigt an, ob Seite seit Einlagerung verändert wurde
\item \textbf{Swap-Bereich:} Reservierter Festplattenbereich für ausgelagerte Seiten
\end{itemize}

\textbf{Kosten eines Seitenfehlers:}
\begin{itemize}
\item Festplattenzugriff $\approx 10^5$ CPU-Instruktionen
\item Seitenfehler dürfen nur sehr selten auftreten ($< 10^{-4}$)
\end{itemize}

\subsection{Seitenauslagerungsstrategien}
\textbf{Optimale Strategie (theoretisch):}
\begin{itemize}
\item Lagere Seite aus, die am weitesten in der Zukunft benutzt wird
\item Nicht implementierbar (Hellsehen unmöglich)
\item Dient als Vergleichsmaßstab
\end{itemize}

\textbf{LRU (Least Recently Used):}
\begin{itemize}
\item Lagere am längsten unbenutzte Seite aus
\item Beste praktische Approximation der optimalen Strategie
\item \textbf{Problem:} Aufwändige exakte Implementierung
\end{itemize}

\textbf{Approximation von LRU:}
\begin{itemize}
\item \textbf{Zugriffsbits (Referenced Bits):} Hardware setzt Bit bei jedem Zugriff
\item \textbf{Schieberegister:} Sammelt Zugriffsmuster über mehrere Perioden
\item \textbf{Second Chance:} FIFO + Zugriffsbits, gibt Seiten zweite Chance
\item \textbf{Clock-Algorithmus:} Zirkuläre Liste + Uhrzeiger, effiziente Implementierung von Second Chance
\end{itemize}

\textbf{Einfachere Strategien:}
\begin{itemize}
\item \textbf{FIFO:} Längste Zeit im Speicher → Problem: kann auch aktive Seiten auslagern
\item \textbf{Nachteile:} Belady-Anomalie möglich (mehr Frames → mehr Seitenfehler)
\end{itemize}

\subsection{Zuweisungsstrategien}
\textbf{Lokalitäten:}
\begin{itemize}
\item \textbf{Lokalitätsprinzip:} Programme greifen zeitlich/räumlich konzentriert auf Speicher zu
\item \textbf{Lokalität:} Menge von Seiten, die über kurzen Zeitraum häufig benutzt werden
\item Beispiele: Schleifen, sequentielle Datenverarbeitung, zusammenhängende Datenstrukturen
\end{itemize}

\textbf{Arbeitsmengenstrategie (Working Set):}
\begin{itemize}
\item \textbf{Arbeitsmenge:} Seiten, die "in letzter Zeit" benutzt wurden
\item \textbf{Fenster:} Betrachteter Zeitraum ($\approx$ 10.000 Zugriffe)
\item \textbf{Strategie:} Jedem Prozess so viele Frames zuteilen, wie Arbeitsmenge groß ist
\item Bei Seitenfehler: Weiteren Frame zuteilen
\item Seite fällt aus Arbeitsmenge: Frame entziehen
\end{itemize}

\textbf{Seitenfehler-Frequenz-Algorithmus (PFF):}
\begin{itemize}
\item Misst Zeit t zwischen Seitenfehlern eines Prozesses
\item Wenn t $\leq$ T: Prozess braucht mehr Frames
\item Wenn t $>$ T: Alle Seiten mit R-Bit = 0 auslagern
\end{itemize}

\subsection{Scheduling bei virtuellem Speicher}
\textbf{Thrashing (Seitenflattern):}
\begin{itemize}
\item System produziert nur noch Seitenfehler, kaum produktive Arbeit
\item \textbf{Ursache:} Summe aller Arbeitsmengen $>$ physischer Speicher
\item \textbf{Lösung:} Weniger Prozesse parallel ausführen
\end{itemize}

\textbf{Scheduling-Aspekte:}
\begin{itemize}
\item Nur so viele Prozesse im Zustand "bereit", dass ihre Arbeitsmengen in den RAM passen
\item Bei Speichermangel: Prozesse komplett stilllegen (alle Seiten auslagern)
\item Vor Reaktivierung: Arbeitsmenge wieder einlagern (Prepaging)
\end{itemize}

\textbf{Benutzergesteuerte Speicherverwaltung:}
\begin{itemize}
\item Programme können Hinweise auf Zugriffsmuster geben
\item Beispiel: Sequentielle Verarbeitung → Seiten schnell wieder auslagern
\item Wichtige Datenstrukturen → bevorzugt im Speicher halten
\end{itemize}

\section{KE 4: Prozesskommunikation}

\subsection{Grundlagen der Prozesskommunikation}
\textbf{Warum Kommunikation?}
\begin{itemize}
\item \textbf{Gemeinsame Betriebsmittel:} Hardware/Software gleichzeitig nutzen
\item \textbf{Kosteneffizienz:} Shared Libraries, gemeinsame Datenbasen
\item \textbf{Wiedereintrittsinvariante Programme:} Ein Programm für mehrere Prozesse
\end{itemize}

\textbf{Prozessarten:}
\begin{itemize}
\item \textbf{Disjunkte Prozesse:} Keine gemeinsamen veränderbaren Daten
\item \textbf{Überlappende Prozesse:} Gemeinsame veränderbare Daten → Race Conditions
\end{itemize}

\textbf{Race Conditions:} Ergebnis hängt von zeitlicher Reihenfolge der Operationen ab

\subsection{Kritische Abschnitte}
\textbf{Definition:}
\begin{itemize}
\item \textbf{Kritischer Abschnitt:} Programmteil mit Zugriff auf gemeinsame Daten
\item \textbf{Unkritischer Abschnitt:} Kein Zugriff auf gemeinsame Daten
\end{itemize}

\textbf{Wechselseitiger Ausschluss (Mutual Exclusion):}
\begin{itemize}
\item Nur ein Prozess darf gleichzeitig im kritischen Abschnitt sein
\item Abstrakte Form: \texttt{enter\_critical\_section} → kritischer Abschnitt → \texttt{leave\_critical\_section}
\end{itemize}

\subsection{Anforderungen an wechselseitigen Ausschluss}
\textbf{5 Grundanforderungen:}
\begin{enumerate}
\item \textbf{Mutual Exclusion:} Höchstens ein Prozess im kritischen Abschnitt
\item \textbf{Deadlock Freedom:} Entscheidung in endlicher Zeit
\item \textbf{Fairness:} Kein Prozess verhungert (Starvation-frei)
\item \textbf{Unabhängigkeit:} Gestoppter Prozess außerhalb kritischem Abschnitt blockiert andere nicht
\item \textbf{Geschwindigkeitsunabhängigkeit:} Keine Annahmen über relative Prozessgeschwindigkeiten
\end{enumerate}

\subsection{Synchronisationsvariablen}
\textbf{Einfache Ansätze (unzureichend):}

\textbf{Alternating Turn:}
\begin{verbatim}
s := 1;
Prozess 1: if s=1 do {...; s:=2}
Prozess 2: if s=2 do {...; s:=1}
\end{verbatim}
\textbf{Problem:} Strikte Alternierung, Selbstbehinderung

\textbf{Flag-Variablen:}
\begin{verbatim}
flag[0] := false; flag[1] := false;
Prozess i: flag[i] := true;
          while flag[1-i] do {};
          {...kritisch...}; flag[i] := false;
\end{verbatim}
\textbf{Problem:} Deadlock möglich

\textbf{Peterson-Algorithmus (korrekt):}
\begin{verbatim}
flag[0]:=false; flag[1]:=false; turn:=0;
Prozess i: flag[i] := true; turn := i;
          while (flag[1-i] and turn=i) do {};
          {...kritisch...}; flag[i] := false;
\end{verbatim}

\subsection{Hardware-Unterstützung}
\textbf{Test-and-Set-Lock (TSL):}
\begin{itemize}
\item \textbf{Atomare Operation:} Liest Wert und setzt ihn auf 1
\item \textbf{Bus wird gesperrt} während TSL-Ausführung
\item \textbf{Funktionsweise:} LOCK=0 (frei), LOCK=1 (belegt)
\end{itemize}

\begin{verbatim}
enter_critical_section:
    TSL RX, LOCK    ; Kopiere LOCK nach RX, setze LOCK=1
    CMP RX, #0      ; War LOCK vorher 0?
    JNE enter_critical_section ; Nein → wiederholen
    RET             ; Ja → weiter

leave_critical_section:
    MOVE LOCK, #0   ; LOCK freigeben
    RET
\end{verbatim}

\textbf{Problem:} Aktives Warten (Busy Waiting) verschwendet CPU-Zeit

\subsection{Semaphore}
\textbf{Konzept (Dijkstra 1968):}
\begin{itemize}
\item \textbf{Semaphor:} Ganzzahlige Variable mit speziellen Operationen
\item \textbf{Initialisierung:} s := k (k gleichzeitige Zugriffe erlaubt)
\end{itemize}

\textbf{Atomare Operationen:}
\begin{itemize}
\item \textbf{down(s) / P(s) / wait(s):} 
  \begin{itemize}
  \item s := s - 1
  \item if s < 0 then blockiere Prozess
  \end{itemize}
\item \textbf{up(s) / V(s) / signal(s):}
  \begin{itemize}
  \item s := s + 1
  \item if s $\leq$ 0 then wecke einen wartenden Prozess
  \end{itemize}
\end{itemize}

\textbf{Implementierung:}
\begin{verbatim}
down(s):
    s := s - 1;
    if s < 0 then begin
        füge Prozess in Warteschlange ein;
        blockiere Prozess;
    end;

up(s):
    s := s + 1;
    if s <= 0 then begin  (* Warteschlange nicht leer *)
        wähle Prozess aus Warteschlange;
        versetze in "bereit"-Zustand;
    end;
\end{verbatim}

\textbf{Semaphor-Typen:}
\begin{itemize}
\item \textbf{Binäre Semaphore:} s $\in$ {0,1}, für Mutual Exclusion
\item \textbf{Allgemeine Semaphore:} s $\geq$ 0, für Ressourcenzählung
\end{itemize}

\textbf{Interpretation des Semaphor-Werts:}
\begin{itemize}
\item s $\geq$ 0: Anzahl verfügbarer Ressourcen
\item s $<$ 0: |s| = Anzahl wartender Prozesse
\end{itemize}

\subsection{Klassische Synchronisationsprobleme}

\subsubsection{Erzeuger-Verbraucher-Problem}
\textbf{Szenario:} Erzeuger produziert Daten, Verbraucher konsumiert sie über Puffer

\textbf{Unbegrenzter Puffer:}
\begin{verbatim}
var inhalt : semaphor;
inhalt := 0;

Erzeuger:                    Verbraucher:
repeat                       repeat
  Erzeuge Ware;               down(inhalt);
  Bringe in Puffer;           Hole aus Puffer;
  up(inhalt);                 Verbrauche Ware;
until false;                until false;
\end{verbatim}

\textbf{Begrenzter Puffer (Kapazität n):}
\begin{verbatim}
var voll, leer, mutex : semaphor;
voll := 0; leer := n; mutex := 1;

Erzeuger:                    Verbraucher:
repeat                       repeat
  Erzeuge Ware;               down(voll);
  down(leer);                 down(mutex);
  down(mutex);                Hole aus Puffer;
  Bringe in Puffer;           up(mutex);
  up(mutex);                  up(leer);
  up(voll);                   Verbrauche Ware;
until false;                until false;
\end{verbatim}

\subsubsection{Philosophen-Problem}
\textbf{Szenario:} n Philosophen an rundem Tisch, n Gabeln, jeder braucht 2 Gabeln zum Essen

\textbf{Naive Lösung (deadlock-anfällig):}
\begin{verbatim}
var gabel : array[0..n-1] of semaphor;
for i := 0 to n-1 do gabel[i] := 1;

Philosoph i:
repeat
  denken;
  down(gabel[i]);        (* linke Gabel *)
  down(gabel[(i+1) mod n]); (* rechte Gabel *)
  essen;
  up(gabel[(i+1) mod n]);
  up(gabel[i]);
until false;
\end{verbatim}

\textbf{Korrekte Lösung:}
\begin{verbatim}
var ausschluss : semaphor; privat : array[0..n-1] of semaphor;
var c : array[0..n-1] of (denken, hungrig, essen);

procedure teste(i):
  if (c[i] = hungrig and 
      c[links(i)] <> essen and 
      c[rechts(i)] <> essen) then
  begin
    c[i] := essen;
    up(privat[i]);
  end;

procedure gabel_nehmen(i):
  down(ausschluss);
  c[i] := hungrig;
  teste(i);
  up(ausschluss);
  down(privat[i]);  (* warte falls nötig *)

procedure gabel_weglegen(i):
  down(ausschluss);
  c[i] := denken;
  teste(links(i));  (* Nachbarn prüfen *)
  teste(rechts(i));
  up(ausschluss);
\end{verbatim}

\subsubsection{Leser-Schreiber-Problem}
\textbf{Szenario:} Mehrere Leser gleichzeitig OK, aber nur ein Schreiber exklusiv

\textbf{Priorität für Leser:}
\begin{verbatim}
var readcount : integer; db, readsem : semaphor;
readcount := 0; db := 1; readsem := 1;

Leser:                       Schreiber:
repeat                       repeat
  down(readsem);              down(db);
  readcount := readcount+1;    Schreibe Daten;
  if readcount=1 then          up(db);
    down(db);                until false;
  up(readsem);
  Lies Daten;
  down(readsem);
  readcount := readcount-1;
  if readcount=0 then
    up(db);
  up(readsem);
until false;
\end{verbatim}

\textbf{Problem:} Schreiber können verhungern

\subsection{Nachrichtenaustausch}
\textbf{Konzept:} Kommunikation ohne gemeinsamen Speicher

\textbf{Ringpuffer-Implementierung:}
\begin{itemize}
\item \textbf{Sender:} Erzeugt Nachrichten, legt sie in Puffer
\item \textbf{Empfänger:} Entnimmt Nachrichten aus Puffer
\item \textbf{Synchronisation:} Semaphore für "leer", "voll", "Zugriffschutz"
\end{itemize}

\textbf{Briefkasten-Prinzip:}
\begin{itemize}
\item \textbf{Einweg-Kommunikation:} A → B (unidirektional)
\item \textbf{Zweiweg-Kommunikation:} A $\leftrightarrow$ B mit Bestätigung (acknowledgment)
\end{itemize}

\subsection{Monitore}
\textbf{Konzept (Hoare 1974):}
\begin{itemize}
\item \textbf{Kapselung:} Daten + Prozeduren in einem Modul
\item \textbf{Automatischer Mutex:} Nur ein Prozess zur Zeit im Monitor
\item \textbf{Bedingungsvariablen:} Für komplexere Synchronisation
\end{itemize}

\textbf{Grundstruktur:}
\begin{verbatim}
monitor monitorname
  Datendeklarationen;
  
  procedure prozedur1(...) { ... }
  procedure prozedur2(...) { ... }
  
  begin
    Initialisierung;
  end monitor;
\end{verbatim}

\textbf{Bedingungsvariablen:}
\begin{itemize}
\item \textbf{wait(c):} Blockiert Prozess, gibt Monitor frei
\item \textbf{signal(c):} Weckt einen wartenden Prozess (falls vorhanden)
\end{itemize}

\textbf{Erzeuger-Verbraucher mit Monitor:}
\begin{verbatim}
monitor erzeuger_verbraucher;
  buffer : array[0..N-1] of item;
  in, out, count : integer;
  notfull, notempty : condition;
  
  procedure insert(x);
  begin
    if count = N then wait(notfull);
    buffer[in] := x;
    in := (in + 1) mod N;
    count := count + 1;
    signal(notempty);
  end;
  
  procedure remove(x);
  begin
    if count = 0 then wait(notempty);
    x := buffer[out];
    out := (out + 1) mod N;
    count := count - 1;
    signal(notfull);
  end;
  
begin
  in := 0; out := 0; count := 0;
end monitor;
\end{verbatim}

\subsection{Deadlocks (Systemverklemmungen)}
\textbf{Definition:} Eine Menge von Prozessen befindet sich im Deadlock, wenn jeder Prozess auf ein Ereignis wartet, das nur von einem anderen Prozess der Menge ausgelöst werden kann.

\textbf{Vier notwendige Bedingungen (Coffman et al.):}
\begin{enumerate}
\item \textbf{Wechselseitiger Ausschluss:} Ressourcen können nur exklusiv benutzt werden
\item \textbf{Hold-and-Wait:} Prozesse halten Ressourcen und warten auf weitere
\item \textbf{Keine Unterbrechung:} Ressourcen können nicht entzogen werden
\item \textbf{Zyklisches Warten:} Geschlossene Kette von Prozessen und Ressourcen
\end{enumerate}

\textbf{Deadlock-Strategien:}

\textbf{1. Erkennung und Beseitigung (Detection):}
\begin{itemize}
\item \textbf{Zustandsdarstellung:} Matrizen für Allokation, Anforderung, Verfügbarkeit
\item \textbf{Erkennungsalgorithmus:} Suche nach beendbaren Prozessen
\item \textbf{Beseitigung:} Prozesse abbrechen oder Ressourcen entziehen
\end{itemize}

\textbf{Erkennungsalgorithmus:}
\begin{verbatim}
for i := 1 to n do beendbar[i] := false;
repeat
  noch_einer_beendbar := false;
  for i := 1 to n do
    if not beendbar[i] then
      if Anforderung[i] <= Verfügbar then
      begin
        beendbar[i] := true;
        Verfügbar := Verfügbar + Allokation[i];
        noch_einer_beendbar := true;
      end;
until not noch_einer_beendbar;

deadlock := exists i: not beendbar[i];
\end{verbatim}

\textbf{2. Vermeidung (Avoidance):}
\begin{itemize}
\item \textbf{Banker-Algorithmus:} Basiert auf maximalen Anforderungen
\item \textbf{Sichere Zustände:} Existiert Ausführungsreihenfolge ohne Deadlock
\item \textbf{Problem:} Maximale Anforderungen meist unbekannt
\end{itemize}

\textbf{3. Verhinderung (Prevention):}
\begin{itemize}
\item \textbf{Wechselseitiger Ausschluss aufheben:} Meist unmöglich
\item \textbf{Hold-and-Wait verhindern:} Alle Ressourcen auf einmal anfordern
\item \textbf{Unterbrechung erlauben:} Ressourcenentzug (nicht immer möglich)
\item \textbf{Lineare Ordnung:} Ressourcen nur in fester Reihenfolge anfordern
\end{itemize}

\textbf{4. Ignorieren ("Vogel-Strauß-Strategie"):}
\begin{itemize}
\item Problem wird ignoriert (Windows, Linux)
\item Benutzer muss selbst eingreifen
\item Begründung: Deadlocks sehr selten
\end{itemize}

\textbf{Übergreifende Strategie:}
\begin{itemize}
\item \textbf{Interne Ressourcen:} Verhinderung durch lineare Ordnung
\item \textbf{Hauptspeicher:} Verhinderung durch Swapping
\item \textbf{Prozessressourcen:} Vermeidung mit Voranmeldung
\item \textbf{Swap-Bereich:} Verhinderung durch Vorausallokation
\end{itemize}

\section{KE 5: Geräteverwaltung \& Dateisysteme}

\subsection{Ein-/Ausgabe-Geräte}
\textbf{Gerätetypen nach Zweck:}
\begin{itemize}
\item \textbf{Sekundärspeicher:} Permanente Speicherung (Festplatten, Bänder, optische Speicher)
  \begin{itemize}
  \item Arbeitsdaten: Täglich benötigt, schneller Zugriff
  \item Sicherungskopien: Backup-Daten, langsamerer Zugriff OK
  \item Archivierte Daten: Langzeitspeicherung (Jahrzehnte)
  \end{itemize}
\item \textbf{Ausgabegeräte:} Bildschirme, Drucker, Lautsprecher
\item \textbf{Eingabegeräte:} Tastaturen, Mäuse, Scanner
\item \textbf{Kommunikationsgeräte:} Ethernet, Modems, WLAN
\end{itemize}

\textbf{Gerätetypen nach Übertragungseinheit:}
\begin{itemize}
\item \textbf{Block-Geräte:} Übertragung in Blöcken fester Größe (Festplatten, Bänder)
\item \textbf{Zeichen-Geräte:} Byteweise Übertragung ohne Blockstruktur (Terminals, Drucker)
\end{itemize}

\subsection{Ein-/Ausgabe-Kommunikationstechniken}
\textbf{Controller (Geräte-Steuereinheit):}
\begin{itemize}
\item Hardware zwischen CPU und Geräten
\item Mehrere Geräte pro Controller möglich (z.B. USB: bis 127 Geräte)
\item Entlastet CPU von elementaren Steuerungsaufgaben
\item Eigene Prozessoren für Prüfsummen, Fehlerkorrektur
\end{itemize}

\textbf{CPU-Controller-Kommunikation:}
\begin{itemize}
\item \textbf{I/O-Ports:} Spezielle Befehle \texttt{IN/OUT} für Registeradressen
\item \textbf{Memory-mapped I/O:} Controller-Register im Hauptspeicher-Adressraum
\end{itemize}

\textbf{Drei E/A-Techniken:}

\textbf{1. Programmgesteuerte E/A:}
\begin{itemize}
\item CPU fragt Statusregister ab (Polling, Busy Waiting)
\item Synchrone Abarbeitung
\item \textbf{Nachteil:} CPU komplett belegt bis E/A beendet
\end{itemize}

\textbf{2. Interrupt-gesteuerte E/A:}
\begin{itemize}
\item \textbf{Ablauf:} CPU gibt Auftrag → wird blockiert → Interrupt bei Fertigstellung → CPU fortgesetzt
\item Ermöglicht überlappende E/A-Operationen
\item CPU kann andere Prozesse bearbeiten
\end{itemize}

\textbf{3. DMA (Direct Memory Access):}
\begin{itemize}
\item Controller kann direkt auf Hauptspeicher zugreifen
\item \textbf{DMA-Register:} Quelle, Ziel, Anzahl Bytes, Richtung
\item CPU nur für Initialisierung und Abschluss involviert
\item \textbf{Ablauf:} CPU initialisiert → DMA überträgt → Interrupt bei Fertigstellung
\end{itemize}

\subsection{E/A-Software-Schichtenmodell}
\textbf{Von unten nach oben:}
\begin{enumerate}
\item \textbf{Interrupt-Handler:} Verarbeitet alle Unterbrechungen
\item \textbf{Gerätetreiber:} Geräteabhängige Funktionen
  \begin{itemize}
  \item Ein Treiber pro Controller-Typ
  \item Übersetzt abstrakte Befehle in konkrete Hardware-Operationen
  \item Beispiel: Blockadresse → Zylinder, Sektor, Oberfläche
  \end{itemize}
\item \textbf{Geräteunabhängige E/A-Software:}
  \begin{itemize}
  \item Einheitliche Schnittstelle für alle Geräte
  \item Pufferung, Fehlerbehandlung, Gerätezuteilung
  \end{itemize}
\item \textbf{Benutzer-E/A-Software:} Systemaufrufe, Libraries
\end{enumerate}

\textbf{Wichtige Funktionen der geräteunabhängigen Schicht:}
\begin{itemize}
\item \textbf{E/A-Auftragslistenverwaltung:} Warteschlangen pro Gerät
\item \textbf{Gerätezustandstabelle:} Status aller angeschlossenen Geräte
\item \textbf{Pufferung:} Double Buffering, Ringpuffer für Effizienz
\item \textbf{Spooling:} Simulation exklusiver Geräte (Drucker)
\item \textbf{Geräteallokation:} Zuteilung und Freigabe von Geräten
\end{itemize}

\subsection{Festplatten (Magnetplatten)}
\textbf{Physischer Aufbau:}
\begin{itemize}
\item \textbf{Scheiben:} Mehrere übereinander (2-10), gemeinsame Achse
\item \textbf{Oberflächen:} Beide Seiten jeder Scheibe beschichtet
\item \textbf{Arme:} Bewegliche Lese-/Schreibköpfe zwischen Scheiben
\item \textbf{Spuren:} Kreisförmige Linien auf Oberflächen
\item \textbf{Zylinder:} Spuren gleichen Radius übereinander
\item \textbf{Sektoren:} Unterteilung der Spuren (0,5-4 KB)
\end{itemize}

\textbf{Sektoradressierung:}
\begin{itemize}
\item \textbf{Sektoradresse:} (Zylinder z, Oberfläche o, Sektor s)
\item \textbf{Sektornummer:} $(z \times O + o) \times S + s$
\item Wo O = Anzahl Oberflächen, S = Sektoren pro Spur
\end{itemize}

\textbf{Zugriffszeiten:}
\begin{itemize}
\item \textbf{Suchzeit:} Positionierung der Köpfe (1-10 ms)
\item \textbf{Latenzzeit:} Warten auf richtigen Sektor (durchschnittlich halbe Umdrehung, 2,8-7 ms)
\item \textbf{Übertragungszeit:} Datentransfer ($T = \frac{b}{\omega n}$ Sekunden für b Bytes)
\item \textbf{Gesamte Zugriffszeit = Suchzeit + Latenzzeit + Übertragungszeit}
\end{itemize}

\textbf{Optimierungsverfahren:}
\begin{itemize}
\item \textbf{SSTF (Shortest Seek Time First):} Nächster Auftrag mit geringster Suchzeit
  \begin{itemize}
  \item Problem: Starvation möglich
  \end{itemize}
\item \textbf{SCAN (Elevator):} Arme wandern alternierend nach außen/innen
  \begin{itemize}
  \item Verhindert Starvation, faire Bedienung
  \end{itemize}
\item \textbf{Interleaving:} Sektoren überspringen beim Schreiben
  \begin{itemize}
  \item Grund: Zeit für Datenübertragung zum Hauptspeicher
  \item Interleave Factor bestimmt Anzahl übersprungener Sektoren
  \end{itemize}
\end{itemize}

\textbf{Partitionierung:}
\begin{itemize}
\item \textbf{Master Boot Record (MBR):} Sektor 0 mit Bootcode und Partitionstabelle
\item \textbf{Partitionstypen:} Primär (max. 4), erweitert mit logischen Laufwerken
\item \textbf{High-Level-Formatierung:} Anlegen des Dateisystems pro Partition
\end{itemize}

\subsection{Optische Speicher \& Flash}
\textbf{Optische Platten:}
\begin{itemize}
\item \textbf{CD-ROM:} Nur lesbar, ~650 MB
\item \textbf{CD-R/DVD±R:} Einmal beschreibbar
\item \textbf{CD-RW/DVD±RW:} Wiederbeschreibbar
\item \textbf{Blu-ray:} Bis 25 GB pro Layer
\item Langsamere Übertragung als Festplatten, aber wechselbar
\end{itemize}

\textbf{Flash-Speicher (SSD):}
\begin{itemize}
\item \textbf{NAND vs. NOR:} NAND für Massenspeicher, NOR für Code
\item \textbf{Erase Blocks:} 128-256 KB, nur blockweise löschbar
\item \textbf{Pages:} Kleinste Lese-/Schreibeinheit innerhalb Block
\item \textbf{Wear Leveling:} Gleichmäßige Abnutzung aller Blöcke
\item \textbf{Garbage Collection:} Aufräumen ungültiger Daten
\end{itemize}

\textbf{Flash Translation Layer (FTL):}
\begin{itemize}
\item \textbf{Adressübersetzung:} Logische → physische Blöcke
\item \textbf{Bad Block Management:} Defekte Blöcke ausblenden
\item \textbf{Wear Leveling:} Hot/Cold Data auf Young/Old Blocks verteilen
\end{itemize}

\subsection{Dateisysteme - Grundlagen}
\textbf{Datei-Konzept:}
\begin{itemize}
\item \textbf{Datei:} Sammlung zusammengehöriger Informationen
\item \textbf{Dateisystem:} Menge von Dateien + Verzeichnissen + Hilfsdaten
\item \textbf{Transparenz:} Details der Speicherung verborgen
\end{itemize}

\textbf{Dateierungen:}
\begin{itemize}
\item Beliebig viele Dateien verschiedener Größe
\item Sinnvolle Organisation in Verzeichnissen
\item Strukturierte Zugriffe (Zeichen, Sätze)
\item Zugriffskontrolle zwischen Benutzern
\end{itemize}

\subsection{Dateiverzeichnisse}
\textbf{Hierarchische Dateisysteme:}
\begin{itemize}
\item \textbf{Wurzelverzeichnis:} Einstiegspunkt ins Dateisystem
\item \textbf{Pfadnamen:}
  \begin{itemize}
  \item \textbf{Absolut:} Beginnend mit \texttt{/} oder \texttt{\textbackslash}
  \item \textbf{Relativ:} Bezogen auf aktuelles Arbeitsverzeichnis
  \end{itemize}
\item \textbf{Navigation:} \texttt{cd} für Verzeichniswechsel, \texttt{..} für Elternverzeichnis
\end{itemize}

\textbf{Dateiattribute:}
\begin{itemize}
\item \textbf{Größe:} Aktuelle Dateigröße in Bytes
\item \textbf{Besitzer:} Kontrolle über Zugriffsrechte
\item \textbf{Zugriffsrechte:} Lesen, Schreiben, Ausführen
\item \textbf{Zeitstempel:} Erstellung, letzter Zugriff, letzte Änderung
\item \textbf{Dateityp:} Anwendbare Zugriffsmethode
\item \textbf{Speicherort:} Verweise auf Datenblöcke
\end{itemize}

\subsection{Verwaltung der Dateisektoren}
\textbf{1. File Allocation Table (FAT):}
\begin{itemize}
\item \textbf{Prinzip:} Zentrale Tabelle mit einem Eintrag pro Sektor
\item \textbf{Verkettung:} Sektoren einer Datei als verknüpfte Liste
\item \textbf{Startsektor:} Steht im Verzeichniseintrag
\item \textbf{Vorteile:} Einfach, gut für sequentiellen Zugriff
\item \textbf{Nachteile:} Gesamte FAT muss im RAM sein (bei 20 GB $\approx$ 80 MB)
\end{itemize}

\textbf{Beispiel FAT-Eintrag:}
\begin{verbatim}
Datei "spiel" in Sektoren 3,27,19:
Verzeichnis: spiel → Startsektor 3
FAT[3] = 27, FAT[27] = 19, FAT[19] = nil
\end{verbatim}

\textbf{2. i-nodes (Index-Nodes):}
\begin{itemize}
\item \textbf{Prinzip:} Separate Datenstruktur pro Datei
\item \textbf{Inhalt:} Dateimetadaten + Zeiger auf Datenblöcke
\item \textbf{Mehrstufige Indirektion:}
  \begin{itemize}
  \item 10 direkte Zeiger (Blöcke 0-9)
  \item 1 einfach indirekter Zeiger (Blöcke 10 bis 9+x)
  \item 1 doppelt indirekter Zeiger (Blöcke 10+x bis 9+x+x²)
  \item 1 dreifach indirekter Zeiger (Blöcke 10+x+x² bis 9+x+x²+x³)
  \end{itemize}
\item \textbf{Vorteile:} Nur benötigte i-nodes im RAM, gut für kleine/große Dateien
\item \textbf{Beispiel:} x=256 → max. Dateigröße $\approx$ 16 GB
\end{itemize}

\textbf{3. NTFS (NT File System):}
\begin{itemize}
\item \textbf{MFT (Master File Table):} Array von 1 KB-Einträgen
\item \textbf{Sektorfolgen:} Kompakte Darstellung zusammenhängender Blöcke
\item \textbf{Format:} (Startblock, Länge) statt einzelner Blockadressen
\item \textbf{Journaling:} Protokollierung aller Operationen für Crash-Recovery
\item \textbf{Eindeutige Nummern:} 48 Bit Position + 16 Bit Sequenznummer
\end{itemize}

\subsection{Verwaltung freier Sektoren}
\textbf{1. Verkettete Liste:}
\begin{itemize}
\item Alle freien Sektoren als verknüpfte Liste
\item \textbf{Bei FAT:} Nutzung der FAT-Struktur selbst
\item \textbf{Bei Direktverwaltung:} Folgezeiger im Sektor selbst (I/O-intensiv)
\item \textbf{Verbesserung:} Gruppierung (x Nummern pro Indexblock)
\end{itemize}

\textbf{2. Bitmap:}
\begin{itemize}
\item \textbf{Ein Bit pro Sektor:} 1=frei, 0=belegt
\item \textbf{Vorteile:} Einfaches Löschen, wortweise Suche möglich
\item \textbf{Nachteile:} Bei fast voller Platte langsame Suche
\item \textbf{Speicherbedarf:} Bei 20 GB $\approx$ 2,5 MB für Bitmap
\end{itemize}

\subsection{Optimierungen}
\textbf{E/A-Puffer:}
\begin{itemize}
\item \textbf{Zweck:} Zwischenspeicherung für mehrere Prozesse
\item \textbf{Double Buffering:} Ein Puffer wird gefüllt, anderer geleert
\item \textbf{Cache-Strategien:} LRU, FIFO für Pufferersetzung
\end{itemize}

\textbf{Asynchrones Schreiben:}
\begin{itemize}
\item \textbf{Synchron:} Warten bis Daten auf Platte (sicher)
\item \textbf{Asynchron:} Rückkehr nach Pufferung (schnell)
\end{itemize}

\textbf{Vorausschauendes Lesen:}
\begin{itemize}
\item Bei sequentiellem Zugriff: Nächste Blöcke vorab laden
\item Read-ahead basierend auf Zugriffsmuster
\end{itemize}

\textbf{Suchzeitreduktion:}
\begin{itemize}
\item \textbf{i-node-Lokalität:} i-nodes nahe bei Datenblöcken
\item \textbf{Reorganisation:} Zusammenhängende Speicherung
\item \textbf{Zylindergruppen:} Aufteilen der Platte in Bereiche
\end{itemize}

\subsection{Zugriffsmethoden}
\textbf{Zugriffsstrukturen:}
\begin{itemize}
\item \textbf{Sequentiell:} Wie verknüpfte Liste, nur Anhängen möglich
\item \textbf{Direktzugriff statisch:} Array-artig, direkter Zugriff über Index
\item \textbf{Direktzugriff dynamisch:} Index-sequentiell mit Schlüsseln
\end{itemize}

\textbf{Speichereinheiten:}
\begin{itemize}
\item \textbf{Zeichen:} Byteweise, linearer Adressraum
\item \textbf{Sätze:} Strukturierte Einheiten
  \begin{itemize}
  \item Feste vs. variable Länge
  \item Satzende-Markierung oder Längenfeld
  \end{itemize}
\end{itemize}

\subsection{Magnetbänder}
\textbf{Eigenschaften:}
\begin{itemize}
\item \textbf{Sequentieller Zugriff:} Nur vorwärts/rückwärts
\item \textbf{Variable Blockgrößen} möglich
\item \textbf{Gaps:} Lücken zwischen Blöcken nötig
\item \textbf{Wechselbare Datenträger}
\end{itemize}

\textbf{Anwendung:}
\begin{itemize}
\item \textbf{Backup:} Günstig pro MB, langsamer Zugriff OK
\item \textbf{Archivierung:} Langzeitspeicherung
\item \textbf{Tape Libraries:} Automatische Bandwechsler
\end{itemize}

\textbf{Operationen:}
\begin{itemize}
\item \texttt{read/write next/previous block}
\item \texttt{skip n blocks forward/backward}
\item \texttt{rewind to beginning}
\end{itemize}

\section{KE 6: Sicherheit}

\subsection{Ziele \& Begriffe}
\begin{itemize}
\item \textbf{Ziele:} Vertraulichkeit, Integrität, Verfügbarkeit
\item \textbf{Subjekt:} Aktive Entität (Prozess, Benutzer)
\item \textbf{Objekt:} Passive Entität (Datei, Gerät)
\end{itemize}

\subsection{Kernmechanismen}
\textbf{Authentisierung:} Wer bist du? (Passwort)

\textbf{Autorisierung (Zugriffskontrolle):} Was darfst du?
\begin{itemize}
\item \textbf{ACL (Access Control List):} Pro Objekt eine Liste mit Rechten für Subjekte
\item \textbf{Capability:} Pro Subjekt eine Liste mit Tickets für Objekte
\end{itemize}

\textbf{DAC (Discretionary):} Besitzer legt Rechte fest

\textbf{MAC (Mandatory):} System erzwingt globale Regeln
\begin{itemize}
\item \textbf{Bell-LaPadula (Vertraulichkeit):} "No Read Up, No Write Down"
\item \textbf{Biba (Integrität):} "No Read Down, No Write Up"
\end{itemize}

\section{KE 7: Kommandosprachen}

\subsection{Kommandointerpreter (Shell)}
\begin{itemize}
\item Schnittstelle zwischen Benutzer und BS
\item Startet Prozesse (typisch: \texttt{fork()} \& \texttt{exec()})
\item Verwaltet die Prozessumgebung (Variablen, offene Dateien)
\item \textbf{I/O-Umlenkung:}
  \begin{itemize}
  \item \texttt{>} leitet Ausgabe in Datei um
  \item \texttt{<} liest Eingabe aus Datei
  \item \texttt{|} (Pipe) leitet Ausgabe eines Prozesses als Eingabe an den nächsten weiter
  \end{itemize}
\item \textbf{Shell-Skripte:} Automatisierung von Kommandoabfolgen mit Variablen und Kontrollstrukturen
\end{itemize}

\end{multicols*}

\end{document}