\documentclass[9pt,a4paper]{extarticle}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[margin=0.6in]{geometry}
\usepackage{multicol}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{array}
\usepackage{tabularx}
\usepackage{booktabs}

% Compact spacing
\setlength{\parindent}{0pt}
\setlength{\parskip}{2pt}
\setlist{nosep,leftmargin=12pt}

% Colors
\definecolor{sectioncolor}{RGB}{0,51,102}
\definecolor{subsectioncolor}{RGB}{0,76,153}

% Section formatting
\titleformat{\section}{\color{sectioncolor}\large\bfseries}{\thesection}{0.5em}{}
\titleformat{\subsection}{\color{subsectioncolor}\normalsize\bfseries}{\thesubsection}{0.5em}{}
\titlespacing*{\section}{0pt}{6pt}{3pt}
\titlespacing*{\subsection}{0pt}{4pt}{2pt}

% Header
\pagestyle{fancy}
\fancyhf{}
\fancyhead[C]{\textbf{Betriebssysteme Cheat Sheet - Kurs 01670 FernUni Hagen}}
\fancyfoot[C]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% Fix for better table formatting
\renewcommand{\arraystretch}{1.1}

\begin{document}

\begin{center}
{\huge\textbf{Betriebssysteme - Das ultimative Cheat Sheet}}\\
\vspace{2mm}
{\large Basierend auf Kurs 01670 - FernUniversität in Hagen}
\end{center}

\vspace{3mm}
\hrule
\vspace{3mm}

\begin{multicols*}{2}
\small

\section{KE 1: Einführung \& Grundlagen}

\subsection{Was ist ein Betriebssystem (BS)?}
\textbf{Definition:} Menge von Programmen, die es ermöglichen, den Rechner zu betreiben und Anwendungsprogramme auf ihm auszuführen.

\textbf{Zwei Hauptsichten:}
\begin{itemize}
\item \textbf{Abstrakte/Virtuelle Maschine:} Verbirgt Hardware-Komplexität, bietet einfache Schnittstelle (API)
\item \textbf{Ressourcen-Manager:} Verwaltet \& verteilt Ressourcen (CPU, Speicher, Geräte) fair und effizient
\end{itemize}

\subsection{Aufgaben eines Betriebssystems}
\textbf{Klassische Aufgaben:}
\begin{itemize}
\item \textbf{Gerätesteuerung:} Verbergen der Hardware-Besonderheiten, Anbieten von Diensten
\item \textbf{Schutz:} Speicherschutz, Zugriffschutz zwischen Benutzern
\item \textbf{Fehlerbehandlung:} Division durch 0, illegale Adressen, Hardware-Defekte
\item \textbf{Mehrprogrammbetrieb:} Parallele Ausführung mehrerer Programme
\item \textbf{Prozess-Synchronisation/-Kommunikation:} Nachrichtenaustausch, Synchronisation
\item \textbf{Ressourcenverwaltung:} CPU, E/A-Geräte, Hauptspeicher, Kommunikationsverbindungen
\item \textbf{Kommandosprache:} Textuelle/grafische Schnittstelle zum System
\item \textbf{Administration:} Datensicherung, Systemkonfiguration, Leistungsüberwachung
\end{itemize}

\subsection{Systemarchitektur \& Ebenenmodell}
\textbf{Ebenenmodell (von unten nach oben):}
\begin{enumerate}
\item \textbf{Digitale Logikebene:} Gatter, Boole'sche Funktionen
\item \textbf{Mikroprogramm-Ebene:} Mikrobefehle, Mikroprogramme
\item \textbf{Konventionelle Maschinenebene:} Maschinenbefehle des Prozessors
\item \textbf{Betriebssystem-Ebene:} Systemaufrufe erweitern Maschinenebene
\item \textbf{Assembler-Sprachen:} Lesbare Namen für Maschinenbefehle
\item \textbf{Höhere Programmiersprachen:} Hardware-unabhängig
\end{enumerate}

\textbf{Betriebssystem-Komponenten:}
\begin{itemize}
\item \textbf{Kern (Kernel):} Programme, die immer im Hauptspeicher sind
\item \textbf{Standard-Bibliotheken:} Häufig benötigte Funktionen
\item \textbf{Dienstprogramme (Utilities):} Administration, Textverarbeitung
\end{itemize}

\subsection{Hardware-Grundlagen}
\textbf{Unterbrechungen (Interrupts):}
\begin{itemize}
\item \textbf{Hardware-Interrupts:} Asynchrone Signale von Geräten (E/A-Abschluss)
\item \textbf{Software-Interrupts (Traps):} Synchron durch Programmfehler oder Systemaufrufe
\item \textbf{Ablauf:} Signal → CPU unterbricht Programm → Unterbrechungsroutine → Programmfortsetzung
\item \textbf{Unterbrechungsvektor:} Tabelle mit Adressen der Unterbrechungsroutinen
\end{itemize}

\textbf{Speicherschutz:}
\begin{itemize}
\item \textbf{Grenzregister:} Trennt Benutzer- und Betriebssystem-Bereich
\item \textbf{Zweck:} Schutz des BS vor fehlerhaften/bösartigen Programmen
\end{itemize}

\textbf{System- und Benutzermodus:}
\begin{itemize}
\item \textbf{Benutzermodus (User Mode):} Eingeschränkte Befehle, Speicherschutz aktiv
\item \textbf{Systemmodus (Kernel Mode):} Alle Befehle erlaubt, Speicherschutz deaktiviert
\item \textbf{Supervisor Call (SVC):} Kontrollierter Übergang User→Kernel für Systemaufrufe
\end{itemize}

\subsection{Mehrprogrammbetrieb}
\textbf{Motivation:}
\begin{itemize}
\item \textbf{Auslastungsverbesserung:} CPU arbeitet während E/A-Wartezeiten anderer Prozesse
\item \textbf{Parallelität:} Mehrere Benutzer/Programme gleichzeitig
\item \textbf{Virtueller Prozessor:} Jeder Prozess hat Eindruck einer eigenen CPU
\end{itemize}

\textbf{Zeitscheiben:}
\begin{itemize}
\item \textbf{Zeitgeber (Timer):} Hardware-Komponente für regelmäßige Unterbrechungen
\item \textbf{Zeitscheibenablauf:} Unterbrechung nach Ablauf der zugeteilten Zeit
\item \textbf{Prozesswechsel:} Umschaltung zwischen Prozessen
\end{itemize}

\subsection{Betriebsarten}
\textbf{Interaktiver Betrieb (Dialog):}
\begin{itemize}
\item Sofortige Programmausführung, direkte Benutzer-Programm-Kommunikation
\item Time-Sharing: Mehrbenutzer-Dialogsysteme
\item Optimierungsziel: Kurze Antwortzeiten
\end{itemize}

\textbf{Stapelbetrieb (Batch):}
\begin{itemize}
\item Jobs werden in Warteschlange eingereiht, keine direkte Kommunikation
\item Optimierungsziel: Maximale Ressourcenauslastung
\item Höhere Durchsatzraten, längere Wartezeiten akzeptabel
\end{itemize}

\textbf{Hintergrundausführung:}
\begin{itemize}
\item Programme laufen parallel zu interaktiven Prozessen
\item Keine direkte Benutzerinteraktion während der Ausführung
\end{itemize}

\textbf{Realzeitbetrieb:}
\begin{itemize}
\item Harte Zeitgrenzen müssen eingehalten werden
\item Zeitkritische Prozesse haben höchste Priorität
\item Erfordert speziell konstruierten Betriebssystemkern
\end{itemize}

\subsection{Systemstart (Bootstrap)}
\textbf{Ladevorgang:}
\begin{itemize}
\item \textbf{Firmware/BIOS:} In ROM/EPROM gespeichert
\item \textbf{Urlader (Bootstrap Loader):} Lädt Betriebssystem von Festplatte
\item \textbf{Master Boot Record (MBR):} Enthält Startinformationen
\item \textbf{Boot Manager:} Auswahl zwischen mehreren Betriebssystemen
\end{itemize}

\subsection{Historisches Beispiel: CP/M}
\textbf{Komponenten:}
\begin{itemize}
\item \textbf{BIOS:} Hardware-abhängige Gerätetreiber
\item \textbf{BDOS:} Hardware-unabhängige Dateiverwaltung
\item \textbf{CCP:} Kommandointerpreter (Shell)
\item \textbf{TPA:} Transient Program Area (Benutzerbereich)
\end{itemize}

\section{KE 2: Prozesse \& Scheduling}

\subsection{Programm vs. Prozess}
\begin{itemize}
\item \textbf{Programm:} Statische Formulierung eines Algorithmus (Programmtext)
\item \textbf{Prozess:} Ablaufendes Programm inklusive aktueller Stand des Befehlszählers, Registerinhalte und Hauptspeicherbereich mit Variablenbelegungen
\end{itemize}

\subsection{Prozessmerkmale}
\textbf{Prozesszustände:}
\begin{itemize}
\item \textbf{erzeugt:} Datenstrukturen werden erstellt, Adressraum zugewiesen
\item \textbf{bereit:} Rechenbereit, wartet auf Prozessorzuteilung
\item \textbf{rechnend:} Prozessor ist zugeteilt, führt Anweisungen aus
\item \textbf{blockiert:} Wartet auf Ereignis (z.B. E/A)
\item \textbf{beendet:} Programmausführung ist beendet
\end{itemize}

\textbf{Speicherbereich eines Prozesses:}
\begin{itemize}
\item \textbf{Programmsegment:} Ausführbarer Code (ändert sich nicht)
\item \textbf{Stacksegment:} Programmstack mit Aktivierungsblöcken
\item \textbf{Datensegment:} Daten des Programms
\end{itemize}

\textbf{Prozesskontrollblock (PCB):}
\begin{itemize}
\item \textbf{Prozessidentifikation:} Eindeutige Prozess-ID
\item \textbf{Prozessorstatus:} Programmzähler, alle Register
\item \textbf{Prozesskontrollinformationen:} Zustand, Priorität, Speicherbereich, geöffnete Dateien, Buchhaltung, Besitzer
\end{itemize}

\subsection{Zustandsübergänge \& Prozesswechsel}
\textbf{Wichtige Übergänge:}
\begin{itemize}
\item erzeugt → bereit (2): Ressourcen zugeteilt
\item bereit → rechnend (3): Prozessor zugeteilt
\item rechnend → blockiert (5): Warten auf Ereignis
\item blockiert → bereit (6): Ereignis eingetreten
\item rechnend → bereit (4): Zeitscheibe abgelaufen oder freiwillige Abgabe
\item rechnend → beendet (7): Prozess terminiert
\end{itemize}

\textbf{Dispatcher:} Führt Prozesswechsel durch
\begin{itemize}
\item Sichert Prozessorzustand (Register, Programmzähler)
\item Übergibt PCB an Scheduler
\item Stellt Zustand des neuen Prozesses wieder her
\end{itemize}

\textbf{Präemptiv vs. Nicht-präemptiv:}
\begin{itemize}
\item \textbf{Nicht-präemptiv:} Nur Prozess selbst gibt Prozessor ab
\item \textbf{Präemptiv:} Betriebssystem kann Prozessor entziehen (Timer-Interrupt)
\end{itemize}

\subsection{Scheduling-Strategien}
\textbf{Qualitätsmaßstäbe:}
\begin{itemize}
\item Prozessorauslastung, Durchlaufzeit, Durchsatz, Antwortzeit, Fairness
\item CPU burst: Zeit, die Prozess den Prozessor am Stück behalten will
\end{itemize}

\textbf{Nicht-präemptive Verfahren:}

\begin{center}
\begin{tabular}{|p{2.2cm}|p{2.8cm}|p{2.8cm}|}
\hline
\textbf{Verfahren} & \textbf{Vorteile} & \textbf{Nachteile} \\
\hline
\textbf{FCFS} & Einfach, fair, geringer Verwaltungsaufwand & Kurze Prozesse warten lange (Convoy-Effekt) \\
\hline
\textbf{SJF} & Minimale mittlere Wartezeit & Verhungern langer Prozesse, Bedienzeit unbekannt \\
\hline
\textbf{Priority} & Wichtige Aufgaben schnell & Verhungern bei statischen Prioritäten \\
\hline
\end{tabular}
\end{center}

\textbf{Präemptive Verfahren:}

\begin{center}
\begin{tabular}{|p{2.2cm}|p{2.8cm}|p{2.8cm}|}
\hline
\textbf{Verfahren} & \textbf{Vorteile} & \textbf{Nachteile} \\
\hline
\textbf{Round Robin} & Sehr fair, gut für interaktive Systeme & Overhead durch Kontextwechsel \\
\hline
\textbf{SRTF} & Optimal für bekannte Zeiten & Verhungern, viele Unterbrechungen \\
\hline
\textbf{Priority (präemptiv)} & Flexible Prioritäten & Komplexer \\
\hline
\end{tabular}
\end{center}

\textbf{Quantum-Wahl bei Round Robin:}
\begin{itemize}
\item Zu klein: Hoher Verwaltungsaufwand
\item Zu groß: Schlechte Antwortzeiten
\item Optimal: Etwas größer als typische Interaktionszeit
\end{itemize}

\subsection{Kombinierte Strategien}
\textbf{Feedback Scheduling:}
\begin{itemize}
\item Berücksichtigt Vergangenheit des Prozesses
\item Aging: Priorität steigt mit Wartezeit → verhindert Verhungern
\item Rechenzeitabhängig: Neue Prozesse hohe Priorität + kleine Zeitscheibe
\item Bei Quantumverbrauch: Niedrigere Priorität + größere Zeitscheibe
\end{itemize}

\textbf{Multiple Queues:}
\begin{itemize}
\item Verschiedene Klassen (System-, Dialog-, Hintergrundprozesse)
\item Jede Klasse eigene Warteschlange + Scheduler
\item Prozessorzeit-Verteilung zwischen Klassen (z.B. 60\%/30\%/10\%)
\end{itemize}

\textbf{Linux-Scheduler:}
\begin{itemize}
\item \textbf{O(1)-Scheduler:} Konstante Laufzeit, Prioritäten 0-139, aktive/abgelaufene Gruppen
\item \textbf{CFS (Completely Fair):} Virtuelle Zeit pro Prozess, perfekte Fairness angestrebt
\end{itemize}

\subsection{Threads (Leichtgewichtige Prozesse)}
\textbf{Konzept:}
\begin{itemize}
\item Mehrere Ausführungspfade pro Prozess
\item \textbf{Gemeinsam:} Code, Daten, geöffnete Dateien
\item \textbf{Separat:} Programmzähler, Register, Stack
\end{itemize}

\textbf{Realisierungen:}
\begin{center}
\begin{tabular}{|p{3.5cm}|p{4.3cm}|}
\hline
\textbf{Benutzer-Threads} & \textbf{Kernel-Threads} \\
\hline
+ Einfache Realisierung & + Echte Parallelität auf Multiprozessoren \\
+ Schnelles Umschalten & + Ein blockierender Thread stoppt nicht alle \\
- Blockierung stoppt alle & - Aufwändige Realisierung \\
- Keine echte Parallelität & - Langsameres Umschalten \\
\hline
\end{tabular}
\end{center}

\textbf{Anwendungsgebiete:}
\begin{itemize}
\item Mehrprozessor-Maschinen (Parallelisierung)
\item Gerätetreiber (parallele Anfragen-Bearbeitung)
\item Verteilte Systeme (Server mit mehreren Clients)
\end{itemize}

\section{KE 3: Hauptspeicherverwaltung}

\subsection{Grundproblem \& MMU}
Logische Adressen eines Prozesses auf physische Adressen im RAM abbilden. Erledigt von der \textbf{Memory Management Unit (MMU)}.

\subsection{Techniken}
\textbf{Zusammenhängende Zuweisung:}
\begin{itemize}
\item MFT (Feste Partitionen): → \textbf{interne} Fragmentierung
\item MVT (Variable Partitionen): → \textbf{externe} Fragmentierung
\end{itemize}

\textbf{Paging (Seitenorientiert):}
\begin{itemize}
\item Physischer Speicher → \textbf{Seitenrahmen (Frames)}
\item Logischer Speicher → \textbf{Seiten (Pages)}
\item \textbf{Seitentabelle} pro Prozess bildet Pages auf Frames ab
\item Löst externe Fragmentierung
\end{itemize}

\textbf{Virtueller Speicher:}
\begin{itemize}
\item \textbf{Konzept:} Log. Adressraum > phys. Speicher. Teile des Prozesses liegen auf Festplatte (Swap-Bereich)
\item \textbf{Mechanismus: Demand Paging.} Seite wird erst bei Bedarf geladen
\item \textbf{Seitenfehler (Page Fault):} Zugriff auf eine nicht geladene Seite
\item \textbf{Seitenauslagerung:} Wenn kein Rahmen frei ist, wird eine Seite ersetzt (z.B. via \textbf{LRU}-Algorithmus)
\item \textbf{Thrashing:} System ist nur noch am Seiten-Swappen, weil Prozesse zu wenige Frames haben
\end{itemize}

\section{KE 4: Synchronisation \& Deadlocks}

\subsection{Problem: Race Conditions}
In \textbf{kritischen Abschnitten}, wo mehrere Prozesse auf gemeinsame Ressourcen zugreifen. Benötigt \textbf{wechselseitigen Ausschluss}.

\subsection{Mechanismen}
\textbf{Semaphore (Dijkstra):} Zählervariable mit atomaren Operationen:
\begin{itemize}
\item \texttt{down()} (P, wait): Blockiert, wenn Zähler $\leq$ 0
\item \texttt{up()} (V, signal): Weckt ggf. wartenden Prozess
\end{itemize}

\textbf{Monitore:} Hochsprachenkonstrukt, das Daten und Prozeduren kapselt und Mutex automatisch sicherstellt.

\subsection{Deadlocks}
\textbf{Definition:} Zyklisches Warten von Prozessen auf Ressourcen.

\textbf{4 notwendige Bedingungen:}
\begin{enumerate}
\item Wechselseitiger Ausschluss
\item Hold and Wait
\item Keine Unterbrechung
\item Zyklisches Warten
\end{enumerate}

\textbf{Umgang:} Verhinderung, Vermeidung, Erkennung \& Behebung, oder Ignorieren ("Vogel-Strauß-Algorithmus").

\section{KE 5: Geräte- \& Dateiverwaltung}

\subsection{Geräteverwaltung}
\begin{itemize}
\item \textbf{Controller:} Hardware, die Geräte steuert
\item \textbf{Gerätetreiber:} Software, die mit dem Controller kommuniziert
\item \textbf{DMA (Direct Memory Access):} Ermöglicht Datentransfer zwischen Gerät und Speicher ohne CPU-Beteiligung
\end{itemize}

\subsection{Dateisystem}
\begin{itemize}
\item \textbf{Datei:} Abstraktion für permanenten Speicher
\item \textbf{Verzeichnis:} Hierarchische Struktur zur Organisation
\item \textbf{Dateizuordnung} (Wie werden Blöcke gespeichert?):
  \begin{itemize}
  \item \textbf{FAT (File Allocation Table):} Verkettete Liste der Blöcke in zentraler Tabelle
  \item \textbf{i-node (Index-Node):} Datenstruktur pro Datei mit Metadaten und Zeigern (direkt/indirekt) auf Datenblöcke (Standard in UNIX)
  \end{itemize}
\end{itemize}

\section{KE 6: Sicherheit}

\subsection{Ziele \& Begriffe}
\begin{itemize}
\item \textbf{Ziele:} Vertraulichkeit, Integrität, Verfügbarkeit
\item \textbf{Subjekt:} Aktive Entität (Prozess, Benutzer)
\item \textbf{Objekt:} Passive Entität (Datei, Gerät)
\end{itemize}

\subsection{Kernmechanismen}
\textbf{Authentisierung:} Wer bist du? (Passwort)

\textbf{Autorisierung (Zugriffskontrolle):} Was darfst du?
\begin{itemize}
\item \textbf{ACL (Access Control List):} Pro Objekt eine Liste mit Rechten für Subjekte
\item \textbf{Capability:} Pro Subjekt eine Liste mit Tickets für Objekte
\end{itemize}

\textbf{DAC (Discretionary):} Besitzer legt Rechte fest

\textbf{MAC (Mandatory):} System erzwingt globale Regeln
\begin{itemize}
\item \textbf{Bell-LaPadula (Vertraulichkeit):} "No Read Up, No Write Down"
\item \textbf{Biba (Integrität):} "No Read Down, No Write Up"
\end{itemize}

\section{KE 7: Kommandosprachen}

\subsection{Kommandointerpreter (Shell)}
\begin{itemize}
\item Schnittstelle zwischen Benutzer und BS
\item Startet Prozesse (typisch: \texttt{fork()} \& \texttt{exec()})
\item Verwaltet die Prozessumgebung (Variablen, offene Dateien)
\item \textbf{I/O-Umlenkung:}
  \begin{itemize}
  \item \texttt{>} leitet Ausgabe in Datei um
  \item \texttt{<} liest Eingabe aus Datei
  \item \texttt{|} (Pipe) leitet Ausgabe eines Prozesses als Eingabe an den nächsten weiter
  \end{itemize}
\item \textbf{Shell-Skripte:} Automatisierung von Kommandoabfolgen mit Variablen und Kontrollstrukturen
\end{itemize}

\end{multicols*}

\end{document}